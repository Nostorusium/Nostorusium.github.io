<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"nostorusium.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="第九章 虚拟内存 虚拟地址空间映射与虚拟存储器概念 系统构成与实现 动态存储器分配与管理技术  物理与虚拟寻址CPU访问内存的最自然方式是使用物理寻址早期的PC使用物理寻址,而现代处理器使用虚拟寻址CPU通过虚拟地址来访问主存CPU芯片上的内存管理单元MMU(memory management unit)负责地址翻译将虚拟地址转换为物理地址">
<meta property="og:type" content="article">
<meta property="og:title" content="CSAPP第九章-虚拟内存">
<meta property="og:url" content="https://nostorusium.github.io/2024/01/17/CSAPP-9/index.html">
<meta property="og:site_name" content="Nostorusium&#39;s inventory">
<meta property="og:description" content="第九章 虚拟内存 虚拟地址空间映射与虚拟存储器概念 系统构成与实现 动态存储器分配与管理技术  物理与虚拟寻址CPU访问内存的最自然方式是使用物理寻址早期的PC使用物理寻址,而现代处理器使用虚拟寻址CPU通过虚拟地址来访问主存CPU芯片上的内存管理单元MMU(memory management unit)负责地址翻译将虚拟地址转换为物理地址">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-01-17T11:55:59.862Z">
<meta property="article:modified_time" content="2024-01-17T12:02:23.187Z">
<meta property="article:author" content="Nostorusium">
<meta property="article:tag" content="CS原理">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://nostorusium.github.io/2024/01/17/CSAPP-9/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://nostorusium.github.io/2024/01/17/CSAPP-9/","path":"2024/01/17/CSAPP-9/","title":"CSAPP第九章-虚拟内存"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>CSAPP第九章-虚拟内存 | Nostorusium's inventory</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Nostorusium's inventory</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">亚拉戈西瓜的杂货堆</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="nav-number">1.</span> <span class="nav-text">第九章 虚拟内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E4%B8%8E%E8%99%9A%E6%8B%9F%E5%AF%BB%E5%9D%80"><span class="nav-number">1.1.</span> <span class="nav-text">物理与虚拟寻址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="nav-number">1.2.</span> <span class="nav-text">虚拟内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E8%A1%A8"><span class="nav-number">1.2.1.</span> <span class="nav-text">页表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7"><span class="nav-number">1.2.2.</span> <span class="nav-text">局部性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98"><span class="nav-number">1.2.3.</span> <span class="nav-text">如何管理内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4"><span class="nav-number">1.2.4.</span> <span class="nav-text">内存保护</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91"><span class="nav-number">1.2.5.</span> <span class="nav-text">地址翻译</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E8%A1%A8TLB"><span class="nav-number">1.2.6.</span> <span class="nav-text">快表TLB</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="nav-number">1.2.7.</span> <span class="nav-text">多级页表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AB%AF%E5%88%B0%E7%AB%AF%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91"><span class="nav-number">1.2.8.</span> <span class="nav-text">端到端地址翻译</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.2.9.</span> <span class="nav-text">Linux虚拟内存系统</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E4%B8%8E%E7%A7%81%E6%9C%89"><span class="nav-number">1.3.</span> <span class="nav-text">共享与私有</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">1.4.</span> <span class="nav-text">内存分配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">1.4.1.</span> <span class="nav-text">动态内存分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#malloc%E4%B8%8Efree"><span class="nav-number">1.4.2.</span> <span class="nav-text">malloc与free</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E5%99%A8%E7%9A%84%E8%A6%81%E6%B1%82%E4%B8%8E%E7%9B%AE%E6%A0%87"><span class="nav-number">1.4.3.</span> <span class="nav-text">分配器的要求与目标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A2%8E%E7%89%87"><span class="nav-number">1.4.4.</span> <span class="nav-text">碎片</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8"><span class="nav-number">1.4.5.</span> <span class="nav-text">隐式空闲链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%BE%E7%BD%AE%E7%AD%96%E7%95%A5"><span class="nav-number">1.4.6.</span> <span class="nav-text">放置策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%89%B2%E7%A9%BA%E9%97%B2%E5%9D%97"><span class="nav-number">1.4.7.</span> <span class="nav-text">分割空闲块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%9D%E5%A4%96%E5%A0%86%E5%86%85%E5%AD%98"><span class="nav-number">1.4.8.</span> <span class="nav-text">额外堆内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E7%A9%BA%E9%97%B2%E5%9D%97"><span class="nav-number">1.4.9.</span> <span class="nav-text">合并空闲块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%A6%E8%BE%B9%E7%95%8C%E6%A0%87%E8%AE%B0%E7%9A%84%E5%90%88%E5%B9%B6"><span class="nav-number">1.4.10.</span> <span class="nav-text">带边界标记的合并</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%BE%E5%BC%8F%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8"><span class="nav-number">1.4.11.</span> <span class="nav-text">显式空闲链表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E5%99%A8%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.5.</span> <span class="nav-text">分配器实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.5.1.</span> <span class="nav-text">内存模型系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E4%B8%8E%E5%AE%8F"><span class="nav-number">1.5.2.</span> <span class="nav-text">常用函数与宏</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A0%86%E4%B8%8E%E6%89%A9%E5%B1%95%E5%A0%86"><span class="nav-number">1.5.3.</span> <span class="nav-text">初始化堆与扩展堆</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8A%E6%94%BE%E4%B8%8E%E5%90%88%E5%B9%B6%E5%9D%97"><span class="nav-number">1.5.4.</span> <span class="nav-text">释放与合并块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E5%9D%97"><span class="nav-number">1.5.5.</span> <span class="nav-text">分配块</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86"><span class="nav-number">1.6.</span> <span class="nav-text">垃圾收集</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Nostorusium"
      src="/images/aris.jpg">
  <p class="site-author-name" itemprop="name">Nostorusium</p>
  <div class="site-description" itemprop="description">这是好的</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/nostorusium" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;nostorusium" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://nostorusium.github.io/2024/01/17/CSAPP-9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/aris.jpg">
      <meta itemprop="name" content="Nostorusium">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nostorusium's inventory">
      <meta itemprop="description" content="这是好的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="CSAPP第九章-虚拟内存 | Nostorusium's inventory">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CSAPP第九章-虚拟内存
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-01-17 19:55:59 / 修改时间：20:02:23" itemprop="dateCreated datePublished" datetime="2024-01-17T19:55:59+08:00">2024-01-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="第九章-虚拟内存"><a href="#第九章-虚拟内存" class="headerlink" title="第九章 虚拟内存"></a>第九章 虚拟内存</h2><ul>
<li>虚拟地址空间映射与虚拟存储器概念</li>
<li>系统构成与实现</li>
<li>动态存储器分配与管理技术</li>
</ul>
<h3 id="物理与虚拟寻址"><a href="#物理与虚拟寻址" class="headerlink" title="物理与虚拟寻址"></a>物理与虚拟寻址</h3><p>CPU访问内存的最自然方式是使用物理寻址<br>早期的PC使用物理寻址,而现代处理器使用虚拟寻址<br>CPU通过虚拟地址来访问主存<br>CPU芯片上的内存管理单元MMU(memory management unit)负责地址翻译将虚拟地址转换为物理地址</p>
<span id="more"></span>

<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p><strong>虚拟内存</strong>被组织为一个存放在<strong>磁盘</strong>上连续字节大小的单元组成的数组<br>每字节都有一个唯一的<strong>虚拟地址</strong>作为<strong>索引</strong><br>与其他层次的缓存一样磁盘上的数据也被划分成块,在主存与磁盘之间传输<br>虚拟内存被分割成固定大小的块,称<strong>虚拟页</strong>(virtual page)<br>在物理内存则称为<strong>物理页</strong>(physical page),大小相同<br>物理页也称作<strong>页帧</strong>(page frame)</p>
<p>虚拟页面的集合被划分为三种</p>
<ul>
<li><strong>未分配的</strong> VM系统未分配&#x2F;创建的页 没有任何数据 也不占用磁盘空间</li>
<li><strong>缓存的</strong> 这些虚拟页在物理内存中已缓存</li>
<li><strong>未缓存的</strong> 未缓存在物理内存但实际上已分配的页</li>
</ul>
<p><strong>SRAM</strong>缓存指L1,L2,L3高速缓存<br>而我们使用<strong>DRAM</strong>来表示虚拟内存系统的缓存,他在主存中缓存虚拟页,把主存当做磁盘上划分出的虚拟页的缓存</p>
<h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p>VM系统必须能够判定一个虚拟页是否缓存在DRAM中,<br>如果是,还必须确定这一虚拟页放在哪个物理页中.<br>如果不命中,系统要判断该虚拟页在磁盘中的位置,并在物理内存中选择一个牺牲页,并用虚拟页替换掉<br>这些功能由软硬件联合提供,包括操作系统,MMU中的地址翻译硬件,与一个存放在物理内存中的<strong>页表</strong>(page table)</p>
<p>页表将虚拟页映射到物理页,<strong>地址翻译硬件</strong>转换地址时会<strong>读取页表</strong><br><strong>操作系统</strong>负责<strong>维护页表</strong>的内容并在磁盘与DRAM之间<strong>传送页</strong></p>
<p>每一个虚拟页都对应了一个<strong>页表条目</strong>(Page Table Entry)(即页表项)<br>PTE由一位有效位和n位地址字段组成</p>
<ul>
<li>设置了有效位 表示该页已缓存在DRAM中,地址字段表示其物理页的起始位置</li>
<li>没有设置有效位 如果地址未空,表示该虚拟页未分配 不然表示虚拟页在磁盘上的起始位置</li>
</ul>
<p>DRAM缓存不命中成为缺页(page fault),这会触发一个缺页异常,调用内核的缺页异常处理程序,该程序选择一个牺牲页</p>
<h4 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h4><p>由于局部性原理,这种页面调度工作的相当好<br>局部性原理保证了在任意时刻,程序趋向于在一个较小的活动页面集合上工作<br>称之为工作集(working set)或者常驻集合(resident set)<br>在缓存了这些集合中的页后,对这个工作集的引用都会导致命中<br>只要程序有好的时间局部性,虚拟内存工作系统就能工作得相当好</p>
<p>然而如果时间局部性不够好,工作集的大小变得很大超出了物理内存的大小<br>则会产生抖动,页面不断地换进换出</p>
<h4 id="如何管理内存"><a href="#如何管理内存" class="headerlink" title="如何管理内存"></a>如何管理内存</h4><p>虚拟内存大大简化了内存管理,并提供了自然地保护内存的方法</p>
<ul>
<li><strong>简化链接</strong> 操作系统为每一个进程都提供了一个独立的页表,因而也就是一个独立的虚拟地址空间,这允许每个进程的映像都使用相同的基本格式,例如64位地址空间而言代码段总是从虚拟地址0x40000开始.格式的一致性极大地简化了链接器的设计与实现</li>
<li><strong>简化加载</strong> 把目标文件.text与.data节加载到新进程的过程中,加载器(loader)只需为代码与数据段分配虚拟页,标记为未被缓存的,将页表条目指向目标文件中的恰当位置,虚拟内存系统即可自动地按需调入数据页</li>
<li><strong>简化共享</strong> 对于进程私有代码,操作系统会创建页表,把虚拟页映射到不同的物理页 在一些情况中,例如每个进程调用相同的内核代码,将不同进程中虚拟页面映射到相同的物理页,从而共享这段代码的一个副本</li>
<li><strong>简化内存分配</strong> 当程序要求额外的堆空间时(如malloc),操作系统分配<strong>连续的虚拟内存页面</strong>,而可以把他们映射到<strong>物理内存</strong>中的<strong>任意位置</strong></li>
</ul>
<h4 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h4><p>如果对PTE添加一些许可位,如<strong>SUP,READ,WRTIE</strong>来标识这个页的是否需要内核态与对读写的控制<br>当指令违反了这些许可条件,CPU触发一个故障保护,控制传递给异常处理程序<br>Linux shell一般称这种异常为段错误(segmentation fault)</p>
<h4 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h4><p>CPU中的<strong>页表基址寄存器PTBR</strong>(Page Table Base Register)指向页表<br>一个n位虚拟地址包含两部分:</p>
<ul>
<li>p位<strong>虚拟页面偏移</strong>VPO(Virtual Page Offset):代表所指页的页内偏移</li>
<li>n-p位<strong>虚拟页号</strong>VPN(Virtual page Number):虚拟页号指向页表中的某一项</li>
</ul>
<p>MMU根据虚拟页号VPN来确定页表中的某一页表条目PTE<br>对于已缓存的虚拟页,其页表项中给出了<strong>物理页号</strong>PPN(Physical Page Number)<br>现在将<strong>物理页号</strong>PPN与<strong>页内偏移</strong>VPO拼在一起就可以得到<strong>物理地址</strong></p>
<p>页面命中的过程如下</p>
<ul>
<li>处理器把虚拟地址传送给MMU</li>
<li>MMU得到虚拟页号,向高速缓存&#x2F;主存请求读页表中的PTE</li>
<li>高速缓存&#x2F;主存返回所请求的PTE</li>
<li>MMU把PTE中得到的PPN与虚拟页号中的VPO拼在一起,构造出物理地址,传送给高速缓存&#x2F;主存</li>
<li>高速缓存&#x2F;主存返回所请求的数据字给处理器</li>
</ul>
<p>页面命中完全由硬件处理,而对于不命中则需要操作系统内核协作完成</p>
<ul>
<li>处理器把虚拟地址传送给MMU</li>
<li>MMU得到虚拟页号,向高速缓存&#x2F;主存请求读页表中的PTE</li>
<li>高速缓存&#x2F;主存返回所请求的PTE</li>
<li>PTE中有效位是0,触发缺页异常,控制传递给缺页异常处理程序</li>
<li>缺页处理程序确定出物理内存的牺牲页,如果这个页面已被修改则换出到磁盘</li>
<li>调入新的页面,更新页表中的PTE</li>
<li>缺页处理程序返回到原来的进程,再次执行导致缺页的指令.CPU将虚拟地址重新发送给MMU.因为已把对应页换入内存,这会导致命中,接下来进入页面命中的流程</li>
</ul>
<h4 id="快表TLB"><a href="#快表TLB" class="headerlink" title="快表TLB"></a>快表TLB</h4><p>每次产生虚拟地址的过程MMU都要查PTE<br>在MMU中加入一个关于PTE的小缓存快表TLB(Translation Lookaside Buffer)来试图消除这样的开销<br>PTE保存着由单个PTE组成的块</p>
<p>当TLB命中时,所有的地址翻译都在MMU中执行,非常快</p>
<ul>
<li>CPU传递虚拟地址</li>
<li>MMU得到虚拟页号,查TLB得到所求PTE</li>
<li>TLB返回请求的PTE</li>
<li>MMU翻译出物理地址,传递给高速缓存&#x2F;主存</li>
<li>高速缓存&#x2F;主存返回请求的数据字</li>
</ul>
<p>TLB不命中时,MMU需要从L1中取出所求PTE,并放入TLB.这可能会牺牲已有的PTE块</p>
<p>TLB的<strong>索引与标记字段</strong>来自于虚拟地址的<strong>虚页号字段</strong><br>&lt;标记位&gt;&lt;索引位&gt;<VPO></p>
<h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><p>假设地址空间32位,页面大小4KB,PTE大小4B<br>$\frac{2^{32}}{4*2^{10}}<em>4 &#x3D; 4</em>2^{20}&#x3D;4MB$<br>这意味着即便只引用一小部分虚拟地址空间,也需要4MB的页表常驻内存<br>如果地址空间64位,则需要$2^{54}B$的页表,我们无法承受这样的代价</p>
<p>压缩页表的常用方法是使用层级结构的页表<br>以二级页表为例<br>一级页表中的每个PTE映射到一个二级页表<br>二级页表中的PTE才映射到物理内存<br>基于上述假设不变,<br>考虑一个大小为4KB的一级页表,<br>一级页表有$4KB&#x2F;4B&#x3D;1024$个PTE<br>每个一级PTE指向一个二级页表<br>每个二级页表大小4KB,也容纳1024个PTE,负责映射到物理内存<br>此时,一级页表与每个二级页表的页表</p>
<p>大小与一个页面大小一样都是4KB<br>这从两个方面减少了内存要求</p>
<ul>
<li>如果一级页表的PTE为空,则其二级页表根本不会存在,从而节约了空间</li>
<li>只有一级页表常驻主存,而只有常用的二级页表才会缓存在主存</li>
</ul>
<h4 id="端到端地址翻译"><a href="#端到端地址翻译" class="headerlink" title="端到端地址翻译"></a>端到端地址翻译</h4><p>P573,P577<br>(2022)P577原图</p>
<p>Intel I7默认是4级页表<br>如:32位虚拟页号, 则每级页表32&#x2F;4&#x3D;9位</p>
<h4 id="Linux虚拟内存系统"><a href="#Linux虚拟内存系统" class="headerlink" title="Linux虚拟内存系统"></a>Linux虚拟内存系统</h4><p>Linux缺页异常处理:</p>
<ul>
<li>该虚拟地址是否合法?若不合法,触发段错误(segment fault) 终止该进程</li>
<li>该内存访问是否合法?若不合法,触发保护异常,终止该进程</li>
<li>都合法,认为是缺页引起,进行缺页处理</li>
</ul>
<h3 id="共享与私有"><a href="#共享与私有" class="headerlink" title="共享与私有"></a>共享与私有</h3><p>不同进程的虚拟内存映射到物理内存的同一区域<br>私有对象采用<strong>写时复制</strong></p>
<ul>
<li>两个进程的私有对象映射到了同一个物理副本,标记该区域为<strong>私有的写时复制</strong></li>
<li>在没有进程试图写该区域,则继续共享同一个副本</li>
<li>当有进程试图写该区域,则触发故障保护</li>
<li>在物理内存中创建所写页面的新副本,并更新页表指向这个新的副本页</li>
<li>恢复这个新副本页的可写权限,这样这个新页面上的写操作就可以正常执行</li>
</ul>
<h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p>2021: 简述内存释放并合并空闲块的过程<br>写出内存块释放与空闲块合并的C语言函数 加注释<br>可以使用题目给出的宏与宏函数</p>
<h4 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h4><p>动态内存分配器(dynamic memory allocator)维护一个进程的虚拟内存区域:堆(heap)<br>内核维护一个变量brk(break),指向堆的顶部</p>
<p>分配器视堆位一组不同大小的块(block)的集合 每个块是一个连续的虚拟内存片(chunk) 要么是<strong>已分配的</strong>,要么是<strong>空闲的</strong></p>
<p>已分配的块显示地保留给应用程序使用,<strong>空闲块可以用来分配</strong><br>已分配的块可以被释放,这种释放可以使应用程序显示执行,也可以是内存分配器隐式执行的</p>
<p>有两种风格:</p>
<ul>
<li><strong>显式分配器</strong>(explicit allocator) 要求应用显式地释放已分配的块 如C标准库提供malloc显示分配器 用free来释放</li>
<li><strong>隐式分配器</strong>(implicit allocator) 要求分配器检测已分配块何时不再被使用并释放 也叫<strong>垃圾收集器</strong>(garbage collector) 自动释放已分配的块的过程叫<strong>垃圾收集</strong>(garbage collection) 如Java依赖垃圾收集来释放已分配的块</li>
</ul>
<h4 id="malloc与free"><a href="#malloc与free" class="headerlink" title="malloc与free"></a>malloc与free</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *malloc(size_t size);</span><br></pre></td></tr></table></figure>
<p>malloc返回的指针指向大小至少为size字节的内存块<br>块可能为其内部的数据对象类型做对齐,64位下该地址通常是16的倍数<br>当malloc遇到问题:如要求的内存块过大 就返回NULL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *sbrk(intprt_t incr);</span><br></pre></td></tr></table></figure>
<p>sbrk通过将内核的brk指针增加incr来扩展或收缩堆<br>成功返回brk的旧值 失败返回-1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void free(void *ptr);</span><br></pre></td></tr></table></figure>
<p>ptr必须指向malloc,calloc,realloc获得的已分配块的起始位置<br>不然free的行为将是未定义的 且什么都不返回,也不会告诉应用发生了错误</p>
<h4 id="分配器的要求与目标"><a href="#分配器的要求与目标" class="headerlink" title="分配器的要求与目标"></a>分配器的要求与目标</h4><p>限制要求:</p>
<ul>
<li>只使用堆</li>
<li>对齐块</li>
<li>不破坏已分配的块</li>
<li>立即响应请求</li>
<li>任意的分配与释放序列</li>
</ul>
<p>性能目标:</p>
<ul>
<li>最大化吞吐量(单位时间内完成的请求数)</li>
<li>最大化内存利用率</li>
</ul>
<p>在限制要求下,这两个性能目标通常是相互冲突的</p>
<ul>
<li>若希望吞吐率最大化,则使请求平均时间最小化</li>
<li>峰值利用率 $U_k&#x3D;\frac{max_{i&lt;&#x3D;k}P_i}{H_k},P:payload;H:Heapsize$ 描述了前k+1个请求中利用率的最大值</li>
</ul>
<p>若想利用率最大化,就要尽量减少碎片,多合并空闲块,这意味着更复杂的分配策略,增大了分配时间<br>我们可以以堆利用率为代价写出吞吐率最大化的分配器:使用最简单的分配策略,最小化分配时间</p>
<h4 id="碎片"><a href="#碎片" class="headerlink" title="碎片"></a>碎片</h4><ul>
<li>内部碎片:一个已分配的块比有效载荷大</li>
<li>外部碎片:没有一个单独的空闲块足够大承载载荷</li>
</ul>
<p><strong>外部碎片</strong>的量化要困难得多,且不可能预测,分配器通常采用启发式策略来<strong>维持少量的大空闲块</strong>,而不是维持大量的小空闲块</p>
<h4 id="隐式空闲链表"><a href="#隐式空闲链表" class="headerlink" title="隐式空闲链表"></a>隐式空闲链表</h4><p>任何实际的分配器需要一些数据结构来区分<strong>块的边界,已分配或空闲</strong><br>大多数分配器将这些信息嵌入块本身</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//一个简单的堆块格式</span><br><span class="line">29bit  :  头部,给出块大小</span><br><span class="line">3bit   :  其他信息,如区分已分配/空闲</span><br><span class="line">payload:  载荷</span><br><span class="line">(可选填充)</span><br></pre></td></tr></table></figure>
<p>对这个结构做如下考虑:<br>双字(8B)对齐,则块的大小是8的倍数,块大小字段低3位一定是0<br>所以抽掉3bit用于状态其他信息: 0 0 a 用a指明已分配&#x2F;空闲</p>
<p>考虑一个已分配的块,总大小为24B(0x18)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//其头部:</span><br><span class="line">0x00000018 | 0x1 = 0x00000019</span><br><span class="line">    1 1000</span><br><span class="line">+      001</span><br><span class="line">=   1 1001</span><br><span class="line">0x18+0x1=0x19</span><br></pre></td></tr></table></figure>

<p>我们可以将堆组织为一个连续的已分配块和空闲块的序列 用隐式链表串联<br>空闲块通过头部的大小字段隐含地连接着<br>分配器可以遍历堆中所有的块从而间接遍历空闲块的集合</p>
<p>我们还需要一个特殊的结束块:大小为0,标记位已分配的<strong>终止头部</strong>(terminating header)</p>
<ul>
<li>优点是简单</li>
<li>缺点是任何操作的开销都要求对链表的搜索 搜索时间与块的总数成线性关系</li>
</ul>
<h4 id="放置策略"><a href="#放置策略" class="headerlink" title="放置策略"></a>放置策略</h4><p>找到一个足够大的空闲块放置请求</p>
<p><strong>首次适配</strong>(first fit):选择第一个合适的空闲块</p>
<ul>
<li>倾向于把较大的空闲块保留在链表的后面</li>
<li>缺点是靠近链表起始处留下小空闲块的碎片 增加了对较大块的搜索时间</li>
</ul>
<p><strong>下一次适配</strong>(next fit):在上一次查询结束的位置开始首次适配</p>
<ul>
<li>好处是跳过了首次适配前面可能造成的碎片 更快</li>
<li>但内存利用率比首次适配低很多</li>
</ul>
<p><strong>最佳适配</strong>(best fit):检查所有空闲块,选能满足请求的最小块</p>
<ul>
<li>内存利用率最高</li>
<li>但这要求对堆进行彻底的搜索</li>
</ul>
<h4 id="分割空闲块"><a href="#分割空闲块" class="headerlink" title="分割空闲块"></a>分割空闲块</h4><p>当找到一个匹配的空闲块 要做另一个策略决定:分配该块多少</p>
<ul>
<li>分配整个空闲块:造成内部碎片</li>
<li>分割这个空闲块,分配一部分:产生外部碎片</li>
</ul>
<h4 id="额外堆内存"><a href="#额外堆内存" class="headerlink" title="额外堆内存"></a>额外堆内存</h4><p>如果找不到合适的空闲块:<br>一个选择是合并物理上相邻的空闲块来创建更大的空闲块<br>如果还是不够大,<br>则调用sbrk函数,向内核申请额外的堆内存 分配器把额外的内存转化为一个更大的空闲块,插入空闲链表</p>
<h4 id="合并空闲块"><a href="#合并空闲块" class="headerlink" title="合并空闲块"></a>合并空闲块</h4><p>当一个已分配块被释放,其他空闲块与这个新释放的空闲块相邻,则引起一种现象:<strong>假碎片</strong>(fault fragmentation),许多可用的空闲块被切割成小的,无法使用的空闲块</p>
<p>因此任何实际的分配器都必须<strong>合并</strong>(coalescing)相邻的空闲块<br>何时执行合并又是一个重要的策略决定</p>
<ul>
<li><strong>立即合并</strong>:块被释放时就合并所有的相邻块</li>
<li><strong>推迟合并</strong>:等到某个稍晚的时候再合并(如直到某个分配请求失败再合并)</li>
</ul>
<p>立即合并很简单明了,可以在常数时间内完成<br>但对于某些请求模式会产生一种形式的抖动,块反复地合并又马上被分割<br><strong>快速的分配器</strong>通常会选择某种形式的<strong>推迟合并</strong></p>
<h4 id="带边界标记的合并"><a href="#带边界标记的合并" class="headerlink" title="带边界标记的合并"></a>带边界标记的合并</h4><p>合并当前块的<strong>下一个块</strong>很简单,因为当前块的头部指向下一个块的头部,可以检查指针判断下一个块是否空闲<br><strong>合并前面的块</strong>则需要搜索整个链表,记住前面块的位置 这意味着每次free需要的时间与堆的大小成线性关系</p>
<p>一种聪明而通用的技术:<strong>边界标记</strong>(boundary tag)<br>在每个块的结尾添加一个<strong>头部的副本</strong>:<strong>脚部</strong>(footer)<br>如果每个块都有这样一个脚部<br>则检查当前块开始位置的前一个字的位置,就得到了上一个块的脚部 从而判断上一个块的分配情况</p>
<p>不过这也带来了显著的内存开销</p>
<h4 id="显式空闲链表"><a href="#显式空闲链表" class="headerlink" title="显式空闲链表"></a>显式空闲链表</h4><p>对于隐式空闲链表,块分配与堆块的总数呈线性关系<br>对于通用的分配器,隐式空闲链表并不适合</p>
<p>更好的方法是将空闲块组织为某种形式的<strong>显式数据结构</strong><br>堆可以组织为<strong>双向空闲链表</strong> 每个空闲块中都包含pred于succ</p>
<p>首次适配的分配时间从<strong>块总数</strong>的线性时间减少到<strong>空闲块总数</strong>的线性时间</p>
<h3 id="分配器实现"><a href="#分配器实现" class="headerlink" title="分配器实现"></a>分配器实现</h3><p>第一个字是双字边界对齐,不使用的<strong>填充字</strong><br>后面紧跟:<strong>序言块</strong>:8字节的已分配块,只有header与footer,初始化时创建,永不释放<br>以<strong>结尾块</strong>:大小为0的已分配块 结尾</p>
<h4 id="内存模型系统"><a href="#内存模型系统" class="headerlink" title="内存模型系统"></a>内存模型系统</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/*private global variables*/</span><br><span class="line">static char* mem_heap;      //指向堆的起始地址</span><br><span class="line">static char* mem_brk;       //指向堆的最后一字节+1</span><br><span class="line">static char* mem_max_addr;  //堆的最大合法地址+1</span><br><span class="line"></span><br><span class="line">/*Initialize*/</span><br><span class="line">void mem_init(void)&#123;</span><br><span class="line">    mem_heap = (char*)malloc(MAX_HEAP);</span><br><span class="line">    mem_brk = (char*)mem_heap;                  //初始化为堆起始地址</span><br><span class="line">    mam_max_addr = (char*)(men_heap+MAX_HEAP);  //指向最大合法地址+1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*sbrk implement*/</span><br><span class="line">void* mem_sbrk(int incr)&#123;       //一个简化版sbrk函数</span><br><span class="line">    char *old_brk=mem_brk;</span><br><span class="line">    //报错</span><br><span class="line">    if(incr&lt;0||(mem_brk+incr)&gt;mem_max_addr)&#123;</span><br><span class="line">        errono = ENOMEM;</span><br><span class="line">        fprintf(stderr,&quot;ERROR:mem-sbrk failed:ran out of memory.\n&quot;);</span><br><span class="line">        return (void*)-1;</span><br><span class="line">    &#125;</span><br><span class="line">    mem_brk+=incr;</span><br><span class="line">    return (void*)old_brk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="常用函数与宏"><a href="#常用函数与宏" class="headerlink" title="常用函数与宏"></a>常用函数与宏</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#define WSIZE 4             //字大小4B</span><br><span class="line">#define DSIZE 8             //双字double word 8B</span><br><span class="line">#define CHUNKSIZE (1&lt;&lt;12)   //扩展堆时的默认大小:2^12=4MB</span><br><span class="line"></span><br><span class="line">#define MAX(x,y)</span><br><span class="line"></span><br><span class="line">/*将块大小字段与已分配位拼接 用于header或footer*/</span><br><span class="line">#define PACK(size,alloc) ((size)|(alloc))</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line"> * 读取/写入p所指的字</span><br><span class="line"> * p典型地是一个(void*)指针</span><br><span class="line"> * 强转为unsigned int* 并读取p所指的字</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#define GET(p) (*(unsigned int *)(p))</span><br><span class="line">#define PUT(p,val) (*(unsigned int*)(p) = (val))</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 读p所指的header或footer下SIZE字段与ALLOC位</span><br><span class="line"> * 在当前模型下header与footer刚好占1字</span><br><span class="line"> */</span><br><span class="line">#define GET_SIZE(p) (GET(p) &amp; ~0x7)</span><br><span class="line">#define GET_ALLOC(p) (GET(p) &amp; 0x1)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 给定block ptr bp,计算它header/footer的地址</span><br><span class="line"> * bp指向有效载荷部分</span><br><span class="line"> */</span><br><span class="line">#define HDRP(bp) (char*)bp - WSIZE</span><br><span class="line">#define FTRP(bp) (char*)bp + GET_SIZE(HDRP(bp)) -DSIZE</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 前一个/后一个块的地址</span><br><span class="line"> */</span><br><span class="line">#define NEXT_BLKP(bp) ((char*)(bp) + GET_SIZE(HDRP(bp)))</span><br><span class="line">#define PREV_BLKP(bp) ((char*)(bp) - GET_SIZE(HDRP(bp) - WSIZE))</span><br></pre></td></tr></table></figure>

<h4 id="初始化堆与扩展堆"><a href="#初始化堆与扩展堆" class="headerlink" title="初始化堆与扩展堆"></a>初始化堆与扩展堆</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int mm_init(void)&#123;</span><br><span class="line">    if((heal_listp = mem_sbrk(4*WSIZE)) == (void*)-1)</span><br><span class="line">        return -1;</span><br><span class="line">    PUT(heap_listp,0);                          //填充块</span><br><span class="line">    PUT(heap_listp + 1 * WISZE,PACK(DSIZE,1));  //序言块header</span><br><span class="line">    PUT(heap_listp + 2 * WSIZE,PACK(DSIZE,1));  //序言块footer</span><br><span class="line">    PUT(heap_listp + 3 * WSIZE,PACK(0,1));      //结尾块</span><br><span class="line">    heap_listp += 2*WSIZE;</span><br><span class="line"></span><br><span class="line">    //分配一个块</span><br><span class="line">    if(extend_heap(CHUNKSIZE/WSIZE) == NULL)&#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static void* extend_heap(size_t words)&#123;</span><br><span class="line">    char *bp;</span><br><span class="line">    size_t size;</span><br><span class="line">    size = (word%2) ? (words+1)*WSIZE:words*WSIZE; //对齐</span><br><span class="line">    if((long)(bp=mem_sbrk(size))==-1)</span><br><span class="line">        return NULL;</span><br><span class="line"></span><br><span class="line">    PUT(HDRP(bp),PACK(size,0));</span><br><span class="line">    PUT(FTRP(bp),PACK(size,0));</span><br><span class="line">    PUT(HDRP(NEXT_BLKP(bp)),PACK(0,1));</span><br><span class="line"></span><br><span class="line">    //如果前一个块空闲则合并</span><br><span class="line">    return coalesce(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="释放与合并块"><a href="#释放与合并块" class="headerlink" title="释放与合并块"></a>释放与合并块</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void mm_free(void *bp)&#123;</span><br><span class="line">    size_t size = GETSIZE(HDRP(bp));    //计算当前块大小</span><br><span class="line">    PUI(HDRP(bp),PACK(size,0));         //头部归0</span><br><span class="line">    PUT(FTRP(bp),PACK(size,0));         //尾部归0</span><br><span class="line">    coalesce(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">static void *coalesce(void *bp)&#123;</span><br><span class="line">    size_t prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp))); //前</span><br><span class="line">    size_t next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp))); //后</span><br><span class="line">    size_t size = GET_SIZE(HDRP(bp));                   //当前块大小</span><br><span class="line"></span><br><span class="line">    //前后不空</span><br><span class="line">    if(prev_alloc &amp;&amp; next_alloc) </span><br><span class="line">        return bp;</span><br><span class="line"></span><br><span class="line">    //前不空后空</span><br><span class="line">    if(prev_alloc &amp;&amp; !next_alloc)&#123;</span><br><span class="line">        size += GETSIZE(HDRP(PREV_BLKP(bp)));   //修改大小</span><br><span class="line">        PUT(HDRP(bp),PACK(size,0));             //修改头,释放并合并</span><br><span class="line">        PUT(FTRP(bp),PACK(size,0));             //重写尾</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //前空后不空</span><br><span class="line">    if(!prev_alloc &amp;&amp; next_alloc)&#123;</span><br><span class="line">        size += GETSIZE(HDRP(PREV_BLKP(bp)));   //修改大小</span><br><span class="line">        PUT(FTRP(bp),PACK(size,0));             //写尾</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)),PACK(size,0));  //写头</span><br><span class="line">        bp = PREV_BLKP(bp);                     //bp前移</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //前后都空</span><br><span class="line">    if(!prev_alloc &amp;&amp; !next_alloc)&#123;</span><br><span class="line">        size += GETSIZE(HDRP(PREV_BLKP(bp))) + GET_SIZE(FTRP(NEXT_BLKP(bp)));   //HDRP与FTRP等价 此处为习惯写法</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)),PACK(size,0));                                  //写前头</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)),PACK(size,0));                                  //写后尾</span><br><span class="line">        bp = PREV_BLKP(bp);                                                     //bp前移</span><br><span class="line">    &#125;</span><br><span class="line">    return bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>合并:共4个情况</p>
<ul>
<li>前空后空</li>
<li>前空后不空</li>
<li>前不空后空</li>
<li>前后不空</li>
</ul>
<h4 id="分配块"><a href="#分配块" class="headerlink" title="分配块"></a>分配块</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//向内存请求size大小的块</span><br><span class="line">void *mm_malloc(size_t size)&#123;</span><br><span class="line">    size_t asize;       //调整请求大小</span><br><span class="line">    size_t extendsize;  //拓展堆</span><br><span class="line">    char *bp;</span><br><span class="line"></span><br><span class="line">    if(size==0) return NULL;</span><br><span class="line"></span><br><span class="line">    //最小块大小为双字16B</span><br><span class="line">    if(size &lt; DSIZE)        //小于双字</span><br><span class="line">        asize = 2*DSIZE;    //调整为双字大小 并额外加一双字用于header与footer</span><br><span class="line">    else                    //加入开销字节,向上舍入到最接近8的整数倍</span><br><span class="line">        asize = DSIZE * ((size + DSIZE + DSIZE-1)/DSIZE); //wtf</span><br><span class="line"></span><br><span class="line">    if((bp=find_fit(asize)) !=NULL)&#123;</span><br><span class="line">        place(bp,asize);</span><br><span class="line">        return bp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //没找到,拓展</span><br><span class="line">    extendsize = MAX(asize,CHUNKSIZE);</span><br><span class="line">    if((bp = extend_heap(extendsize/WSIZE))==NULL)  //拓展失败</span><br><span class="line">        return NULL;</span><br><span class="line">    place(bp,asize);</span><br><span class="line">    return bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h3><p>垃圾收集器是一种动态内存分配器 自动释放程序不再需要的块</p>
<p>垃圾收集器将内存视为一张<strong>有向可达图</strong><br>图的结点被分为一组<strong>根节点</strong>与一组<strong>堆结点</strong><br><strong>堆结点</strong>对应了堆中的一个<strong>已分配块</strong><br>有向边 $p→q$ 意味着块p中的某个位置指向块q中的某个位置<br><strong>根节点</strong>对应了一种<strong>不在堆中</strong>的位置,包含指向堆的指针.这些位置可以使寄存器,栈里的变量</p>
<p>当存在从根出发到达p的有向路径,称p结点可达<br>在任何时刻,不可达结点对应垃圾,不能被应用再次使用</p>
<p>如Java的垃圾收集器堆如何应用和创建指针有很严格的控制,能够维护可达图的精准表示,也能回收所有垃圾<br>而如C,C++的收集器通常不能维持可达图的精准表示,这样的收集器也叫<strong>保守的垃圾收集器</strong><br>即一些不可达结点会被错误的标记位可达</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/CS%E5%8E%9F%E7%90%86/" rel="tag"># CS原理</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/01/17/CSAPP-8/" rel="prev" title="CSAPP第八章-异常控制流">
                  <i class="fa fa-angle-left"></i> CSAPP第八章-异常控制流
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Nostorusium</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
